\chapter{Métodos}
\label{cap:Metodos}

Este capítulo deve apresentar as técnicas de investigação usadas na pesquisa. Lembre-se: quem lê o seu trabalho tem de ser capaz de replicá-lo seguindo as indicações presentes neste capítulo.


\section{Procedimentos}
\label{sec:Procedimentos}

Como foi feita a pesquisa? Aqui devem ser descritas as técnicas usadas:

\begin{itemize}
    \item Algoritmos
    \item Pipelines de algoritmos (se for o caso)
    \item Códigos de implementação, se esses detalhes forem essenciais  (raramente são!)
    \item Modelos e técnicas usados (exemplos: classificadores, tipos de redes neurais etc.)
    \item Testes de inferência estatística (se for o caso)
\end{itemize}


\section{Materiais}
\label{sec:Materiais}

De onde vêm os seus dados? Você deve não somente nomear seus conjuntos de dados, apresentando seus autores e páginas Web para acesso, como também descrever a natureza dos dados: são abertos ao público? Qual a fonte usada pelos autores para gerar o conjunto de dados?


\section{Instrumentos}
\label{sec:Instrumentos}

O que você usou para analisar os dados? Descreva brevemente o hardware e o software utilizados.


\section{Alguns exemplos}

\subsection{Algoritmos}

Há muitos pacotes para criar algoritmos. Vou apresentar o que me parece o mais simples de usar: algorithmicx. 

\bigskip  % Força um salto de linha. Use com cuidado!

\begin{algorithmic}
\If {$i\geq maxval$}
    \State $i\gets 0$
\Else
    \If {$i+k\leq maxval$}
        \State $i\gets i+k$
    \EndIf
\EndIf
\end{algorithmic}

\bigskip 

Lembre-se de que tudo o que aparece entre \$ está no modo matemático.

É muito útil colocar os algoritmos dentro do ambiente flutuante \textit{algorithm}. Como no caso dos outros flutuantes, ele fará a melhor escolha quanto ao posicionamento do bloco do algoritmo na página, de acordo com a otimização do fluxo do texto, inclusive colocando um bom espaço de distância entre o ambiente e o texto, evitando a necessidade de forçar saltos de linha como fizemos com \textit{bigskip}. O ambiente traz, ainda, uma forma padronizada de apresentar a legenda com o nome do algoritmo. Por fim, permite gerar uma lista dos algoritmos usados no texto. Veremos esse recurso em funcionamento quando falarmos da classe de documento \textit{book}.

\begin{algorithm}[ht]
\caption{Euclid’s algorithm}\label{euclid}
\begin{algorithmic}[1]
    \Procedure{Euclid}{$a,b$}\Comment{The g.c.d. of $a$ and $b$}
        \State $r\gets a\bmod b$
        \While{$r\not=0$}\Comment{We have the answer if $r$ is 0}
            \State $a\gets b$
            \State $b\gets r$
            \State $r\gets a\bmod b$
        \EndWhile\label{euclidendwhile}
        \State \Return $b$\Comment{The gcd is $b$}
    \EndProcedure
\end{algorithmic}
\end{algorithm}

Ah, você quer mudar as palavras-chave do inglês para o português? É simples:

\algrenewcommand\algorithmicwhile{\textbf{Enquanto}}
\algrenewcommand\algorithmicdo{\textbf{faça}}
\algrenewcommand\algorithmicend{\textbf{Fim}}
\algrenewcommand\algorithmicprocedure{\textbf{Função}}
\algrenewcommand\algorithmicfor{\textbf{Para}}
\algrenewcommand\algorithmicif{\textbf{Se}}
\algrenewcommand\algorithmicthen{\textbf{Então}}
\algrenewcommand\algorithmicelse{\textbf{Senão}}
\algrenewcommand\algorithmicreturn{\textbf{Devolve}}

\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother
\renewcommand{\listalgorithmname}{Lista de Algoritmos}

\begin{algorithm}[ht]
\caption{Algoritmo de Euclides}\label{euclides}
\begin{algorithmic}[1]
    \Procedure{Euclides}{$a, b$}\Comment{MDC de $a$ e $b$}
        \State $r\gets a\bmod b$
        \While{$r\not=0$}\Comment{Se $r = 0$, está resolvido}
            \State $a\gets b$
            \State $b\gets r$
            \State $r\gets a\bmod b$
        \EndWhile
        \State \Return $b$\Comment{O MDC é $b$}
    \EndProcedure
\end{algorithmic}
\end{algorithm}


\subsection{Códigos de programas}

Seus sonhos de ter o seu código com destaque sintático, avanços de tabulador e blocos de execução formatados automaticamente acaba de se tornar realidade! 

Vamos usar o ambiente \textit{minted}. Ele só precisa receber o nome da linguagem que você quer usar. O resto é com ele. Que tal?

\begin{minted}{python}
import numpy as np
    
def incmatrix(genl1, genl2):
    m = len(genl1)
    n = len(genl2)
    M = None  # To become the incidence matrix
    VT = np.zeros((n*m, 1), int)  # Dummy variable
    
    M1 = bitxormatrix(genl1)
    M2 = np.triu(bitxormatrix(genl2), 1) 

    for i in range(m-1):
        for j in range(i+1, m):
            [r, c] = np.where(M2 == M1[i, j])
            for k in range(len(r)):
                VT[(i)*n + r[k]] = 1
                VT[(i)*n + c[k]] = 1
                VT[(j)*n + r[k]] = 1
                VT[(j)*n + c[k]] = 1
                
                if M is None:
                    M = np.copy(VT)
                else:
                    M = np.concatenate((M, VT), 1)
                
                VT = np.zeros((n*m,1), int)
    return M
\end{minted}


\subsection{Redes neurais}

Bem sabemos que os diagramas que exibem arquiteturas de rede podem ser bastante complexos. Para desenhos sofisticados, o mais fácil é usar um dos muitos editores disponíveis. O desenho pronto pode ser exportado como arquivo e incluído no seu documento do \LaTeX{}. Alguns editores, como o GeoGebra, permitem que você exporte o desenho num dos formatos vetoriais, como TikZ, que podem ser incorporados diretamente no corpo do documento.

Para fazer redes neurais simples, existe o pacote \textit{neuralnetwork}, que permite implementar o ambiente de mesmo nome. Com ele, é possível descrever as camadas de uma rede \textit{Feed Forward} e as ligações entre elas. Observe que o comando para conectar os neurônios (\verb|\linklayers|) é dado \textit{depois} da declaração da camada.

\bigskip

\begin{center}  % Este é o ambiente de centralização. Pode ser usado com quase tudo.
\begin{neuralnetwork}[height=5]  % Use o tamanho da maior camada aqui (incluindo bias)
    \newcommand{\x}[2]{$x_#2$}  % Cria um novo comando \x
	\newcommand{\y}[2]{$\hat{y}_#2$}  
	\newcommand{\hfirst}[2]{\small $h^{(1)}_#2$}
	\newcommand{\hsecond}[2]{\small $h^{(2)}_#2$}
	
	% Define as camadas da rede
	\inputlayer[count=3, bias=false, title=Camada de\\entrada, text=\x]
	\hiddenlayer[count=4, bias=true, title=Camada\\escondida 1, text=\hfirst] \linklayers
	\hiddenlayer[count=3, bias=false, title=Camada\\escondida 2, text=\hsecond] \linklayers
	\outputlayer[count=2, title=Camada de\\saída, text=\y] \linklayers
\end{neuralnetwork}
\end{center}
